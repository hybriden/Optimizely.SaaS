#!/usr/bin/env node

/**
 * Auto-generate src/gql/functions.ts
 *
 * This script generates GraphQL query functions that automatically
 * include all discovered content types (pages, components, experiences).
 *
 * Run: node scripts/generate-functions.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import * as config from './config.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Discover all components in a given type directory
 */
function discoverComponentsInDir(type) {
  const components = [];
  const baseDir = config.getAbsolutePath(config.PATHS.cms[type]);

  if (!fs.existsSync(baseDir)) {
    console.log(`‚ö†Ô∏è  Directory not found: ${baseDir}`);
    return components;
  }

  const folders = fs.readdirSync(baseDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  for (const folderName of folders) {
    const indexFile = path.join(baseDir, folderName, config.NAMING.indexFile(folderName));
    const graphqlFile = path.join(baseDir, folderName, config.NAMING.graphqlFile(folderName));

    // Only include if both index and GraphQL fragment exist
    if (fs.existsSync(indexFile) && fs.existsSync(graphqlFile)) {
      components.push({
        name: folderName,
        type: type,
      });
    }
  }

  return components;
}

/**
 * Generate GraphQL inline fragments for discovered types
 */
function generateInlineFragments(components) {
  return components
    .map(comp => `          ... on ${comp.name} {
            ...${comp.name}Data
          }`)
    .join('\n');
}

/**
 * Generate the functions.ts file
 */
function generateFunctionsFile() {
  console.log('üìù Generating src/gql/functions.ts...\n');

  // Discover all components
  const pages = discoverComponentsInDir('page');
  const experiences = discoverComponentsInDir('experience');
  const allTypes = [...pages, ...experiences];

  console.log(`‚úÖ Found ${pages.length} page(s)`);
  pages.forEach(p => console.log(`   - ${p.name}`));

  console.log(`‚úÖ Found ${experiences.length} experience(s)`);
  experiences.forEach(e => console.log(`   - ${e.name}`));

  console.log();

  // Generate inline fragments
  const inlineFragments = generateInlineFragments(allTypes);

  // Generate file content
  const content = `/**
 * ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by scripts/generate-functions.mjs
 * Run 'yarn generate:functions' to regenerate this file.
 *
 * GraphQL query functions that include all discovered content types.
 */

import { gql, type GraphQLClient } from 'graphql-request'
import type * as Types from './graphql'
import { ALL_FRAGMENTS, COMPONENT_FRAGMENT_DEFINITIONS } from './fragments/shared-fragments'

// Define variable types inline since client preset doesn't export them
type GetContentByPathVariables = {
  path: string[];
  locale: string[];
  changeset?: string | null;
}

type GetContentByIdVariables = {
  key: string;
  version?: string | null;
  locale: string[];
  changeset?: string | null;
}

export async function getContentByPath(client: GraphQLClient, variables: GetContentByPathVariables): Promise<any> {
  const query = gql\`
    query getContentByPath($path: [String!]!, $locale: [Locales!], $changeset: String = null) {
      content: _Content(
        where: {_metadata: {url: {default: {in: $path}}, changeset: {eq: $changeset}}}
        locale: $locale
      ) {
        total
        items: item {
          __typename
          _metadata {
            key
            displayName
            types
            url {
              default
              base
            }
          }
          ...IContentData
          ...PageData
${inlineFragments}
        }
      }
    }

    \${ALL_FRAGMENTS}
    \${COMPONENT_FRAGMENT_DEFINITIONS}
  \`

  return client.request(query, variables)
}

export async function getContentById(client: GraphQLClient, variables: GetContentByIdVariables): Promise<any> {
  const query = gql\`
    query getContentById($key: String!, $version: String, $locale: [Locales!], $changeset: String) {
      content: _Content(
        variation: { include: ALL }
        where: {
          _metadata: { key: { eq: $key }, version: { eq: $version }, changeset: { eq: $changeset } }
        }
        locale: $locale
      ) {
        total
        items: item {
          __typename
          _metadata {
            key
            displayName
            types
            version
            published
            url {
              default
              base
            }
          }
          ...IContentData
          ...PageData
${inlineFragments}
        }
      }
    }

    \${ALL_FRAGMENTS}
    \${COMPONENT_FRAGMENT_DEFINITIONS}
  \`

  return client.request(query, variables)
}
`;

  // Write the file
  const outputPath = path.join(config.PATHS.projectRoot, 'src', 'gql', 'functions.ts');
  fs.writeFileSync(outputPath, content, 'utf-8');

  console.log(`‚úÖ Generated: ${outputPath}`);
  console.log(`\n‚ú® Successfully generated functions.ts with ${allTypes.length} content type(s)!`);
}

// Main execution
try {
  generateFunctionsFile();
} catch (error) {
  console.error(`\n‚ùå Error generating functions.ts: ${error.message}`);
  console.error(error.stack);
  process.exit(1);
}
