#!/usr/bin/env node

/**
 * Auto-generate client-registry.ts from discovered components
 *
 * This script scans the filesystem to discover all CMS components and page teasers,
 * then generates the client-registry.ts file with all necessary imports and registrations.
 *
 * Discovery rules:
 * - Components: src/components/cms/component/{Name}/{Name}Index.tsx
 * - Teasers: src/components/cms/page/{Name}/{Name}Teaser.tsx
 *
 * Usage:
 *   node scripts/generate-client-registry.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

/**
 * Discover all components by scanning the component directory
 */
function discoverComponents() {
  const componentDir = path.join(projectRoot, 'src/components/cms/component');

  if (!fs.existsSync(componentDir)) {
    console.warn(`‚ö†Ô∏è  Component directory not found: ${componentDir}`);
    return [];
  }

  const folders = fs.readdirSync(componentDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  const components = [];

  for (const folderName of folders) {
    const indexFile = path.join(componentDir, folderName, `${folderName}Index.tsx`);

    if (fs.existsSync(indexFile)) {
      components.push({
        name: folderName,
        importPath: `./component/${folderName}/${folderName}Index`,
        varName: `${folderName}Component`
      });
    }
  }

  return components;
}

/**
 * Discover all page teasers by scanning the page directory
 */
function discoverTeasers() {
  const pageDir = path.join(projectRoot, 'src/components/cms/page');

  if (!fs.existsSync(pageDir)) {
    console.warn(`‚ö†Ô∏è  Page directory not found: ${pageDir}`);
    return [];
  }

  const folders = fs.readdirSync(pageDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);

  const teasers = [];

  for (const folderName of folders) {
    const teaserFile = path.join(pageDir, folderName, `${folderName}Teaser.tsx`);

    if (fs.existsSync(teaserFile)) {
      teasers.push({
        name: folderName,
        importPath: `./page/${folderName}/${folderName}Teaser`,
        varName: `${folderName}Teaser`
      });
    }
  }

  return teasers;
}

/**
 * Generate the client-registry.ts file content
 */
function generateRegistryContent(components, teasers) {
  const componentImports = components
    .map(c => `import ${c.varName} from '${c.importPath}';`)
    .join('\n');

  const teaserImports = teasers
    .map(t => `import ${t.varName} from '${t.importPath}';`)
    .join('\n');

  const componentEntries = components
    .map(c => `  '${c.name}': ${c.varName},`)
    .join('\n');

  const teaserEntries = teasers
    .map(t => `  '${t.name}': ${t.varName},`)
    .join('\n');

  return `/**
 * Client-Side CMS Component Registry
 *
 * ‚ö†Ô∏è  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by scripts/generate-client-registry.mjs
 * Run 'yarn generate:registry' to regenerate this file.
 *
 * This is a client-safe registry that can be used in client components
 * like ContentAreaRenderer. It only imports components and pages, not
 * experiences which may have server-only dependencies.
 */

'use client';

import { ComponentType } from 'react';

// Import components
${componentImports}

// Note: Pages are NOT imported here to avoid circular dependencies
// Pages use ContentAreaRenderer, which imports this registry
// Only components (blocks) and teasers need to be registered here

// Import teasers
${teaserImports}

/**
 * Component registry types
 */
type CmsComponent = ComponentType<any>;

interface ComponentRegistry {
  [key: string]: CmsComponent;
}

/**
 * Component registry for blocks only
 * Pages are NOT included here to avoid circular dependencies
 */
const COMPONENT_REGISTRY: ComponentRegistry = {
${componentEntries}
};

/**
 * Teaser registry for page types
 * When pages are added to content areas, they render as teasers/cards
 */
const TEASER_REGISTRY: ComponentRegistry = {
${teaserEntries}
};

/**
 * Register a new component dynamically
 *
 * @param typeName - The content type name (e.g., "HeroBlock", "NewsPage")
 * @param component - The React component to register
 */
export function registerComponent(typeName: string, component: CmsComponent): void {
  COMPONENT_REGISTRY[typeName] = component;
}

/**
 * Register a teaser component for a page type
 *
 * @param typeName - The page type name (e.g., "NewsPage")
 * @param component - The teaser component to register
 */
export function registerTeaser(typeName: string, component: CmsComponent): void {
  TEASER_REGISTRY[typeName] = component;
}

/**
 * Get a component for a specific content type
 *
 * @param typeName - The content type name
 * @returns The component or null if not found
 */
export function getComponent(typeName: string): CmsComponent | null {
  return COMPONENT_REGISTRY[typeName] || null;
}

/**
 * Get a teaser component for a page type
 *
 * @param typeName - The page type name
 * @returns The teaser component or null if not found
 */
export function getTeaser(typeName: string): CmsComponent | null {
  return TEASER_REGISTRY[typeName] || null;
}

/**
 * Check if a component is registered
 *
 * @param typeName - The content type name
 * @returns True if the component is registered
 */
export function hasComponent(typeName: string): boolean {
  return typeName in COMPONENT_REGISTRY;
}

/**
 * Check if a teaser is registered for a page type
 *
 * @param typeName - The page type name
 * @returns True if the teaser is registered
 */
export function hasTeaser(typeName: string): boolean {
  return typeName in TEASER_REGISTRY;
}

/**
 * Get all registered component type names
 *
 * @returns Array of registered type names
 */
export function getRegisteredTypes(): string[] {
  return Object.keys(COMPONENT_REGISTRY);
}

/**
 * Get all registered teaser type names
 *
 * @returns Array of page types with teasers
 */
export function getRegisteredTeasers(): string[] {
  return Object.keys(TEASER_REGISTRY);
}
`;
}

/**
 * Main function
 */
async function main() {
  try {
    console.log('üîç Discovering CMS components and teasers...\n');

    // Discover components and teasers
    const components = discoverComponents();
    const teasers = discoverTeasers();

    console.log(`‚úÖ Found ${components.length} component(s):`);
    components.forEach(c => console.log(`   - ${c.name}`));

    console.log(`\n‚úÖ Found ${teasers.length} teaser(s):`);
    teasers.forEach(t => console.log(`   - ${t.name}`));

    // Generate registry file
    const registryContent = generateRegistryContent(components, teasers);
    const registryPath = path.join(projectRoot, 'src/components/cms/client-registry.ts');

    console.log(`\nüìù Generating ${path.relative(projectRoot, registryPath)}...`);
    fs.writeFileSync(registryPath, registryContent, 'utf8');

    console.log(`\n‚ú® Successfully generated client registry!`);
    console.log(`   Total registrations: ${components.length + teasers.length}`);
    console.log(`   - Components: ${components.length}`);
    console.log(`   - Teasers: ${teasers.length}\n`);

  } catch (error) {
    console.error(`\n‚ùå Error generating client registry: ${error.message}`);
    console.error(error.stack);
    process.exit(1);
  }
}

main();
